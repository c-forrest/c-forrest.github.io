<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="可计算性理论初窥"/><meta name="keywords" content="有限自动机, 正则表达式, 图灵机, 可判定性, 可计算性, 博客" /><link rel="alternate" href="/default" title="博客" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://c-forrest.github.io/2021/07/17/note-0004-introduction-to-computability/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>可计算性理论初窥 - 博客</title>
  <meta name="generator" content="Hexo 5.3.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">博客</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">可计算性理论初窥
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-07-17
        </span><span class="post-category">
            <a href="/categories/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/">数学笔记</a>
            <a href="/categories/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/%E5%85%83%E6%95%B0%E5%AD%A6/">元数学</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%AD%90"><span class="toc-text">引子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E9%97%AE%E9%A2%98%E4%B8%8E%E8%AF%AD%E8%A8%80"><span class="toc-text">决策问题与语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">有限自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">正则语言与正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-text">上下文无关文法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%81%B5%E6%9C%BA"><span class="toc-text">图灵机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="toc-text">不可判定问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98"><span class="toc-text">不可计算问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>参考资料：</p>
<ul>
<li>Keith Schwarz. (2016). Slides for Stanford CS103. （<a target="_blank" rel="noopener" href="https://web.stanford.edu/class/archive/cs/cs103/cs103.1164/">链接</a>）</li>
</ul>
<h2 id="引子"><a class="headerlink" href="#引子"></a>引子</h2>
<p>在查资料时偶然看到Stanford CS103的讲义，读了几篇，发现甚为有趣。讲义开始先补充了集合论、证明、数理逻辑与图论的预备知识，然后开始切入可计算性理论和计算复杂度理论的正题。讲义写得十分详尽，配有丰富的例子和生动的图示。不同于以往读过的类似内容的书籍，它没有引入大量晦涩的形式化语言，而是在严谨的前提下，尽可能粗浅地展示这一理论的基本内容，读起来十分顺畅。很多之前不甚了了的内容，这次读过之后都觉得明白不少。于是，决定在这篇笔记里快速地记下其大概内容，作为自己的梳理。</p>
<p>另外，Keith是位非常平易近人的老师。他的每篇讲义中间处，都会有对学生的匿名提问的回答，内容从对课程内容的补充，到对学生大学生活的建议，到对受挫的学生的鼓励，无所不包，甚至有一次他的回答是拒绝某学生晚上同他出去约会的邀约<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<p>本文主要讨论可计算性理论的初步内容。所谓可计算性理论，主要讨论什么样的问题能够通过程序解决。要讨论这个话题，首先要分别对“问题”“程序”“解决”这些字眼做严格的探讨。所谓“问题”，这里主要指决策问题，即给定输入，输出布尔值的问题形式；所谓“程序”，其严格处理则需要介绍不同的计算模型，这包括有限自动机、图灵机等；所谓“解决”，则需要在给定前两者的具体形式后，再具体考量。</p>
<p>本文将顺照该讲义的思路，从有限自动机讲起，逐步引入正则表达式、上下文无关文法、图灵机等计算模型，并讨论正则、可判定、可识别、不可计算等不同层级的可计算性。</p>
<a id="more"></a>
<h2 id="决策问题与语言"><a class="headerlink" href="#决策问题与语言"></a>决策问题与语言</h2>
<p>无论是何种程序或是所谓的计算模型，都可以看作某个黑匣子，给定输入，如果停止运行，将输出某个结果。模型的输入是多种多样的，但要使其能够由计算模型处理，首先就要将其所有信息转化为某种编码。所谓编码，是由程序能够识别的字符集\(\Sigma\)组成的字符串\(s\)。输出自然也是某个字符串。最为简单的输出形式就是输出布尔值。输出为布尔值的问题称为决策问题（decision problem）。等价地，可以看作判断给定的字符串\(s\)是否属于某一字符串集\(L\)；如果是，则输出真，否则输出假。因而，全体决策问题同全体字符串集的幂集一一对应。称某一字符串集\(L\)为语言（language），则指定决策问题，就等价于指定相应的语言。通常意义的解决某一决策问题，则称判定（decide）相应的语言。</p>
<p>从语言的角度，很容易定义语言的交（\(L_1\cap L_2\)）、并（\(L_1\cup L_2\)）、补（\(\bar L\)）等运算。特殊地，还可以定义语言的串接（\(L_1L_2\)），它的元素遍历所有可能的\(L_1\)中字符串串接上\(L_2\)中字符串的结果。还有一种值得注意的运算是Kleene闭包\(L^\ast\)。为定义它，我们首先归纳定义，\(L_n=LL_{n-1}\)，这里，\(L_0=\{\varepsilon\}\)，而\(\varepsilon\)是空字符串；最后定义\(L^\ast=\bigcup_{n=0}^{\infty}L_n\)，即给定语言\(L\)所有有限多次自串接的结果。同样，从语言的角度，计算能力的局限性立马得以显现。全体语言是不可数的，而全体程序由于可编码必然是可数的；所以必然存在无法通过程序判定的语言。</p>
<p>我们的讨论主要集中在决策问题上，因为它具有形式上的简单性。对于更广泛的问题，即输出字符串的所谓搜寻（search）问题，通常通过转化为决策问题的方式进行讨论。比如说，一般的搜寻问题可以分为两步解决：给定输入字符串\(s\)，首先遍历所有可能的输出结果\(r\)，然后对每个可能的\((s,t)\)对，判定是否满足某一二元关系。这样的转化在多数情境下都是有益的。</p>
<h2 id="有限自动机"><a class="headerlink" href="#有限自动机"></a>有限自动机</h2>
<p>我们讨论的首个计算模型是有限自动机（finite automaton）。有限自动机抽象了具有有限存储的计算机。有限自动机对以往信息的全部记忆都存储在有限多个状态中。确定性有限自动机（deterministic finite automaton，或DFA）由有限多个状态、状态转移表和可接受的状态集合给定。它的工作流程如下：</p>
<ul>
<li>开始前，自动机置于某一初始状态；</li>
<li>每读入一个字符，自动机根据当前状态和该读入字符跳转到下一状态；</li>
<li>字符串读完后，自动机根据当前状态是否属于可接受的状态集合返回结果。</li>
</ul>
<blockquote>
<p>比如说，如下有限自动机可用于判定字符串是否以\(aa\)结尾：</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">\(a\)</th>
<th style="text-align:center">\(b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:right">*2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>这里初始状态是0，可接受状态只有2。要到达可接受状态2，只有连续读入两个及以上\(a\)才可以；只要读入\(b\)，就立马返回初始状态。</p>
</blockquote>
<p>由于输入字符串有限长，确定性有限自动机的计算过程必然可以在有限时间内结束；根据最终状态不同，确定性有限自动机将输出接受或拒绝两者之一的结果。设计确定性有限自动机，重点就在于状态的选取和状态转移表的设计。这里确定性的概念是指，每给定某一状态和某一字符，都有唯一确定的状态转移方式。</p>
<p>相对应的是不确定性有限自动机（nondeterministic finite automaton，或NFA）。它容许给定某个状态和字符对，存在零个、一个或多个状态转移方式。当存在多个状态转移方式时，可以视为有限自动机在多个世界线中并行地进行计算；如果存在零个状态转移方式，则该世界线终止。当全部字符读取结束后，如果存在某个世界线中的有限自动机处于可接受的状态，则输出接受，否则输出拒绝。不确定性有限自动机还允许空字符串转移（\(\varepsilon\)-transition），即不消耗任何输入字符串就进行状态转移。</p>
<blockquote>
<p>比如，如下有限自动机可用于判定字符串是否以\(aa\)结尾：</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">\(a\)</th>
<th style="text-align:center">\(b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:center">0, 1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">\(\varnothing\)</td>
</tr>
<tr>
<td style="text-align:right">*2</td>
<td style="text-align:center">\(\varnothing\)</td>
<td style="text-align:center">\(\varnothing\)</td>
</tr>
</tbody>
</table>
<p>这相当于说，每次读到新的字符，就根据当前字符开一条新的世界线，检验剩余字符串是否只有\(aa\)，如果是，则接受，否则直接杀死该世界线；同时，最开始的世界线重复读取新的字符，但是并不发生状态转移。</p>
</blockquote>
<p>不确定性有限自动机除了并行计算外，还可以理解为某种幸运的计算机，总是可以选择能够得出答案的世界线前进。不确定性有限自动机的算法设计更为灵活，它允许先猜测后检验的设计思路。不确定性有限自动机看起来有着更强的计算能力。显然，确定性有限自动机也是不确定性有限自动机，反之则不然。所以，不确定性有限自动机能够判定的语言应当不少于确定性有限自动机能够判定的语言；事实上，也并没有更多。对任意给定的不确定性有限自动机都可以转化为相应的确定性自动机。方法如下：</p>
<ul>
<li>DFA中每个状态都是原NFA中若干个状态的集合；</li>
<li>DFA的初始状态设定为原NFA的初始状态及其空字符串转移能够达到的状态集；</li>
<li>DFA的状态转移设定为其当前状态中每个原NFA的状态在给定字符串转移，并后接可能的空字符串转移的所得原NFA的状态的集合；</li>
<li>DFA的可接受状态设定为所有包括至少一个原NFA的可接受状态的集合。</li>
</ul>
<blockquote>
<p>比如说，前文中的不确定性有限自动机可以转化为如下确定性有限自动机：</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">\(a\)</th>
<th style="text-align:center">\(b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">{0}</td>
<td style="text-align:center">{0,1}</td>
<td style="text-align:center">{0}</td>
</tr>
<tr>
<td style="text-align:right">{0,1}</td>
<td style="text-align:center">{0,1,2}</td>
<td style="text-align:center">{0}</td>
</tr>
<tr>
<td style="text-align:right">*{0,1,2}</td>
<td style="text-align:center">{0,1,2}</td>
<td style="text-align:center">{0}</td>
</tr>
</tbody>
</table>
</blockquote>
<p>可以看到，这样得到的确定性有限自动机和最开始的例子是同构的。这种转化的可能性说明，不确定性的引入并没有扩大有限自动机可计算问题的范围。但由于不确定性自动机能够同时检验多种可能的状态转移，它在表达上更为灵活，而且具有更低的计算复杂度。我们这里只关心可计算性，所以不再区分确定性或不确定性有限自动机。</p>
<h2 id="正则语言与正则表达式"><a class="headerlink" href="#正则语言与正则表达式"></a>正则语言与正则表达式</h2>
<p>有限自动机能够判定的语言称为正则语言（regular language）。这里，使用确定性有限自动机或者不确定性有限自动机是等效的。容易通过构造有限自动机的方式证明，正则语言类对交、并、补、串接和Kleene闭包操作均封闭<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。这意味着正则语言类可以通过这些操作从简单的正则语言归纳地构造出来。比如我们可以选取空语言、只有空字符串的语言和只有单个字符的语言作为最初始的正则语言，然后归纳构造。正则表达式就可以方便地描述这样的构造。比如以\(aa\)结尾的字符串写作\((a\cup b)^\ast aa\)。当然实际使用中，正则表达式还引入了大量语法糖，能够更方便地表达，但总归可以化作这些基本的操作。</p>
<p>我们想考察正则表达式的表达能力。由于正则表达式中每一步操作都是正则语言类内封闭的，这些操作可以逐个地翻译成子有限自动机，最后组合成完整地能够判定该正则表达式所表达的正则语言的有限自动机<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。所以，正则表达式能够表达的语言不会越过全体正则语言类的边界。反过来，任一正则语言都存在相应的正则表达式。要说明这个，我们需要将有限自动机翻译成正则表达式。为此，我们采取如下步骤：</p>
<ul>
<li>首先，在有限自动机的首尾各添加一个状态，分别作为唯一的初始状态和唯一的可接受状态；新的初始状态空字符串转移到原来的初始状态，原来的可接收状态均空字符串转移到新的可接受状态。</li>
<li>按照某一顺序逐个移除原来的状态，移除前将原来的途径该状态的状态转移均替换成相应的正则表达式；</li>
<li>当只剩新添加的两个状态时，所得状态转移的正则表达式就是原有限自动机对应的正则表达式。</li>
</ul>
<blockquote>
<p>我们还是采用最开始的确定性有限自动机来举例。首先添加状态S和E。要移除状态0，需要考虑它有三个汇入（分别来自S、1和2）、一个流出（1）和一个原地转移，所以要移除状态0，需要分别添加S到1、1到1和2到1的状态转移，其正则表达式分别为\(b^\ast a\)、\(bb^\ast a\)和\(bb^\ast a\)。然后移除状态1，需要考虑它现在有两个汇入（分别来自S和2）、一个流出（2）和一个原地转移，所以要移除状态1，需要分别添加S到2和2到2的状态转移，其正则表达式分别为\(b^\ast a(bb^\ast a)^\ast a\)和\(bb^\ast a(bb^\ast a)^\ast a\)。最后，再移除状态2，得到最终的正则表达式为\(b^\ast a(bb^\ast a)^\ast a(bb^\ast a(bb^\ast a)^\ast a)^\ast\)。不确定性有限自动机的正则表达式则简单得多，即\(\Sigma^\ast aa\)。可以证明，这两个正则表达式是等价的。</p>
</blockquote>
<p>所以，正则表达式实际上具有同有限自动机一致的表达能力，它们都恰好能够表达正则语言。</p>
<h2 id="上下文无关文法"><a class="headerlink" href="#上下文无关文法"></a>上下文无关文法</h2>
<p>显然，并非所有语言都是正则的。</p>
<blockquote>
<p>为此，考察如下的例子：</p>
<p>\[L=\{a^nb^n:n\in\mathbb N\}\]</p>
<p>这个语言不可能通过任何有限自动机判定。这是因为对于不同的\(m\)和\(n\)，\(a^m\)和\(a^n\)应当对应着有限自动机中不同的状态，否则这个有限自动机都无法同时接受\(a^mb^m\)和拒绝\(a^nb^m\)；而这样的\(a^n\)有无限多个，这就要求无限多个状态，这与有限自动机的有限性矛盾。</p>
</blockquote>
<p>更一般地，对于某一语言\(L\)，称字符串\(x\)和\(y\)可区分（distinguishable），若存在字符串\(w\)使得\(xw\)和\(yw\)都属于语言\(L\)。如果该语言存在无限多个两两可区分的状态对，则该语言就不是正则的。这称为Myhill-Nerode定理。因而，有限自动机的短板在于它记忆的有限性。</p>
<p>对于这个例子，我们可以通过上下文无关文法（context-free grammer，或CFG）来描述该语言。</p>
<blockquote>
<p>它描述成
\[S=aSb|\varepsilon\]
这个式子的意思是，表达式\(S\)可以随意替换成\(aSb\)或者\(\varepsilon\)，这就可以递归地生成整个语言。</p>
<p>可以考察更为复杂的例子，比如如下的文法可以生成全部自然数四则运算的算术表达式</p>
<p>\[S=S\ op\ S|(S)|int,\ op=+|-|\times|\div\]</p>
<p>它可以生成比如\(int\times(int+int)\)这样的式子。</p>
</blockquote>
<p>注意，这里也说明，上下文无关文法在生成具体表达式的时候，同一生成式中的相同表达式可以通过不同的替换方式替换。</p>
<p>上下文无关文法具有比正则表达式更强的表达能力。容易验证，正则表达式的构造操作中每一步都可以通过上下文无关文法表达，因而上下文无关文法至少具有比正则表达式更强的表达能力。同时，上文也给出了非正则的上下文无关语言的例子。所以，上下文无关文法的表达能力严格更强。</p>
<p>上下文无关语言是上下文无关文法能够表达的语言。一般地，它不能够通过有限自动机判定。能够判定上下文无关语言的计算模型是下推自动机（pushdown automaton）。下推自动机相当于有限自动机加个无限长的栈（stack）。每当读入新的字符，都根据当前字符和栈当前字符进行栈操作和状态转移。上下文无关文法的表达能力和下推自动机的判定能力的等价性证明暂且不提。另外，也存在非上下文无关文法。</p>
<blockquote>
<p>比如下面的例子</p>
<p>\[L=\{a^nb^nc^n:n\in\mathbb N\}\]</p>
<p>这一命题的证明需要对上下文无关语言的结构做更多探究<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。</p>
</blockquote>
<h2 id="图灵机"><a class="headerlink" href="#图灵机"></a>图灵机</h2>
<p>前文描述的计算模型能力都有它的局限性。Turing提出了一种计算模型，称为图灵机（Turing machine）。他假定，这样的计算模型的计算能力足够强大，能够计算一切有效可计算的问题。这称为Church-Turing论题（Church-Turing thesis）。这一论题没有严格的证明，但它是可以证伪的科学命题。现代计算理论正是建立在Church-Turing论题为真<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>的基础上。</p>
<p>图灵机的形式非常简单。图灵机内部具有有限多个状态，并使用包括输入字符串所用字母表在内的有限大小的字母表。至少要保证存在一个图灵机使用但是不属于输入字符串所用的字母表的字符，譬如说“\(\square\)”。图灵机外接一条双向无限长的纸带，其上每个格子能够存储一个字符。输入字符串存储在这条无限长纸带上，左右的所有空位均存储有字符“\(\square\)”。图灵机有个读写头，能够沿纸带左右移动，每次移动一格，可以读取或写入字符。开始工作时，读写头指向纸带上输入字符串的头部，内部状态置于初始状态。每执行一个动作，都首先读取纸带上的当前字符，然后根据内部状态和当前字符决定状态转移、读写头移动方向、是否要进行写操作和写入的字符（如果要写入的话）。图灵机内部有两个特殊状态，分别是接受和拒绝；一旦进入这两个状态，图灵机立马停止运行并输出结果。</p>
<blockquote>
<p>比如说，再次考虑最开始的以\(aa\)结尾的字符串的例子，图灵机的状态转移表可以写作</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">\(a\)</th>
<th style="text-align:center">\(b\)</th>
<th style="text-align:center">\(\square\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:center">1, R, \(a\rightarrow a\)</td>
<td style="text-align:center">0, R, \(b\rightarrow b\)</td>
<td style="text-align:center">Rej</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:center">2, R, \(a\rightarrow a\)</td>
<td style="text-align:center">0, R, \(b\rightarrow b\)</td>
<td style="text-align:center">Rej</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:center">2, R, \(a\rightarrow a\)</td>
<td style="text-align:center">0, R, \(b\rightarrow b\)</td>
<td style="text-align:center">Acc</td>
</tr>
</tbody>
</table>
<p>也就是说，有限自动机的图灵机实现，只需要复刻原来的状态转移表，每一步都执行一步右移但不执行写操作，当读取到\(\square\)字符时，判断当前状态是否是可接受状态，然后直接跳转。我们没有写拒绝和接受时的纸带移动和写操作，因为程序已停止运行，它们不再重要。</p>
<p>我们考虑非正则语言的例子。比如说，我们考察判定\(L=\{a^nb^n:n\in\mathbb N\}\)的图灵机实现。</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">\(a\)</th>
<th style="text-align:center">\(b\)</th>
<th style="text-align:center">\(\square\)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:center">1, R, \(a\rightarrow\square\)</td>
<td style="text-align:center">Rej</td>
<td style="text-align:center">Acc</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:center">1, R, \(a\rightarrow a\)</td>
<td style="text-align:center">1, R, \(b\rightarrow b\)</td>
<td style="text-align:center">2, L, \(\square\rightarrow\square\)</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:center">Rej</td>
<td style="text-align:center">3, L, \(b\rightarrow\square\)</td>
<td style="text-align:center">Rej</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:center">3, L, \(a\rightarrow a\)</td>
<td style="text-align:center">3, L, \(b\rightarrow b\)</td>
<td style="text-align:center">0, R, \(\square\rightarrow\square\)</td>
</tr>
</tbody>
</table>
<p>初始状态是0，检查字符串是否以\(a\)开始：如果是\(a\)，当前位置空，然后进入状态1，不断向右移动到字符串末尾；如果是\(b\)，直接拒绝；如果是空，接受。状态1就是单纯的右移，什么也不做；直到发现空字符，左移，并进入状态2。状态2检查字符串末尾是否是\(b\)，如果是，则置空，进入状态3，不断向左移动到字符串开头；如果不是，直接拒绝。状态3就是单纯的左移，什么也不做；直到发现空字符，右移，并进入状态0。完成这样一个循环后，该图灵机检查了字符串的开头和结尾是否分别是\(a\)和\(b\)，如果是，则清除它们并处理剩余字符串，否则就拒绝。当剩余字符串为空时，接受该字符串。</p>
</blockquote>
<p>不同于有限自动机，图灵机的运行有三种可能的结果：接受、拒绝和循环。这里循环（loop）是指图灵机永远运行，不会在有限时间内接受或拒绝；与之相反的概念叫做停机（halt），这包括接受和拒绝两种情形。总是停机的图灵机叫做判定器（decider）。称某种语言\(L\)可判定（decidable），就是指该语言是某个判定器能够接受的字符串的全体；而称某种语言\(L\)可识别（recognizable），就是指该语言是某个图灵机能够接受的字符串的全体。显然，可判定的语言必然是可识别的。可判定的语言类记作\(\bf R\)，可识别的语言类记作\(\bf RE\)。接下来的部分，我们着手讨论\(\bf R\)和\(\bf RE\)的大小。</p>
<h2 id="不可判定问题"><a class="headerlink" href="#不可判定问题"></a>不可判定问题</h2>
<p>图灵机的功能十分强大。正如同公理集合论的构造哲学一样，过于强大的功能往往会招致矛盾。本节介绍两种非常强大的图灵机功能，它们的存在为构造反例提供了很多可能。</p>
<p>首先，存在一种特殊的图灵机\(U_{TM}\)，叫做通用图灵机（universal Turing machine）。它接受输入\(\langle M,s\rangle\)，其中\(M\)是任意程序，\(s\)是\(M\)的输入；且\(\langle M,s\rangle\)在通用图灵机上的运行结果和\(s\)在\(M\)上的运行结果完全一致。可以将通用图灵机理解为一种可以编程的计算机。通用图灵机可识别的语言记作\(A_{TM}\)。然后，Kleene第二递归定理（Kleene’s second recursion theorem）称，容许构造自我指涉（self-referencing）的程序。也就是说，容许一般的图灵机在程序中调用自身的代码。正如罗素悖论那样，自我指涉的表达能力过于强大，可以用来构造显然的矛盾。</p>
<p>作为首个例子，我们讨论\(A_{TM}\)。我们想知道：任意给定图灵机\(M\)和输入字符串\(s\)，能否判定\(M\)可不可以接受\(s\)？假设这样的程序<code>willAccept</code>存在，我们可以构造如下的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">willAccept</span><span class="params">(<span class="built_in">string</span> program, <span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* implementation */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> myself = getSource();</span><br><span class="line">    <span class="built_in">string</span> input = getInput();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (willAccept(myself, input)) &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accept();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一程序如果要接受某一输入，就要拒绝它；如果要拒绝某一输入，就要接受它。这一矛盾证明了程序<code>willAccept</code>不可能存在。也就是说明\(A_{TM}\)不可判定。但它又依定义是可识别的，\(U_{TM}\)就是它对应的图灵机。它的存在说明，\(\bf R\)是\(\bf RE\)的严格真子集。</p>
<p>类似地，我们可以问，是否存在图灵机，能够判定给定图灵机\(M\)和输入\(\varepsilon\)是否停机。这一问题又称停机问题（halting problem）。停机问题是可识别的，只需要在通用图灵机的实现中，将原来的拒绝状态替换成接受状态就可以了。但是，停机问题同样是不可判定的。如果可以判定停机问题，可以构造自我指涉的程序，使得判定自身停机时，进入死循环，而判定自身不停机时，立即停机。这样的程序同样蕴含矛盾。这就说明，停机问题\(\text{HALT}\)也是可识别但不可判定的问题。</p>
<h2 id="不可计算问题"><a class="headerlink" href="#不可计算问题"></a>不可计算问题</h2>
<p>那么是否存在不可识别的问题呢？当然存在。在本文的开始就通过计数的方式证明这一点。关键是要构造出这样的问题。和上文非常类似，我们可以考虑这样的问题：给定图灵机\(M\)和输入\(s\)，通用图灵机是否进入死循环？这一问题也记作\(\text{LOOP}\)。我们要说明\(\text{LOOP}\)是不可识别的，这也称作是不可计算的。构造可以采取同上文类似的方式<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>，但讲义中采用了一种更为细致的方式。</p>
<p>首先，我们需要给可识别的语言配备一个合适的判定器。对于可识别的语言，什么是可判定的？答案是，如果你给出图灵机能够接受的字符串，那么验证它是对的是可以在有限时间内完成的。我们需要据此设计一个判定器\(V\)。给定图灵机\(M\)，如果\(M\)可以接受字符串\(s\)，那么指定验证方法\(c\)，判定器\(V\)可以接受\(\langle s,c\rangle\)，否则，判定器\(V\)就会拒绝\(\langle s,c\rangle\)；这样的判定器称为语言\(L\)的验证器（verifier），而验证方法称为输入\(s\)的证书（certificate）。严格来说，语言\(L\)的验证器是指某判定器\(V\)，它满足\(s\in L\)当且仅当存在证书\(c\)使得\(V\)接受\(\langle s,c\rangle\)。</p>
<p>任何可识别语言都有这样的验证器。如果语言\(L\)是图灵机\(M\)可识别的，那么\(M\)接受的任何字符串都必然可以在\(M\)运行一定步数\(c\)后接受；所以，只需要将\(M\)在输入字符串\(s\)上运行\(c\)步，如果\(M\)已经接受\(c\)，就返回接受，否则，就返回拒绝。反过来，任何存在验证器的语言都是可识别的。给定验证器\(V\)，可以设计图灵机\(M\)，对于每个输入字符串\(s\)，都遍历所有可能的\(c\in\Sigma^*\)，并执行\(V(s,c)\)；只要\(V\)返回了接受，\(M\)就接受\(s\)，否则\(M\)将一直验证下去。如果\(s\in L\)，那么必然存在这样的\(c\)，程序将在有限时间内终止并接受该字符串\(s\)；否则，程序将不会终止运行；所以这样的\(M\)的确是\(L\)的识别器。所以，语言的可识别性和相应的验证器的存在性是等价的。</p>
<p>我们回到问题\(\text{LOOP}\)上。假定该问题是可识别的，我们用<code>verifyWillLoop</code>来表示相应的验证器程序，然后我们构造如下的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyWillLoop</span><span class="params">(<span class="built_in">string</span> program, <span class="built_in">string</span> input, <span class="built_in">string</span> certificate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* implementation */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> myself = getSource();</span><br><span class="line">    <span class="built_in">string</span> input = getInput();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> certicate: iterator_for_all_strings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyWillLoop(myself, input, certicate)) &#123;</span><br><span class="line">            accept();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果实现该程序的图灵机\(M\)在输入\(s\)时会陷入死循环，那么就存在相应的证书\(c\)可以验证这一点，于是程序会在该证书处终止；而如果图灵机\(M\)在输入\(s\)时不会陷入死循环，那么将永远无法找到对应的证书来验证这一点，程序反而会陷入死循环。这样的矛盾说明，问题\(\text{LOOP}\)并非可识别的。</p>
<p>可判定的问题更接近于通常意义上可解的问题，而可计算的问题更类似于通常意义上可以证明的问题。从这一点上看，死循环问题不可识别是很容易理解的。因为我们无论如何也无法验证某个程序是否永远也无法终止，除了直接运行它到无限时间。存在这样的不可验证的问题，或者说存在这样是真的但是却无法证明的问题，这正是哥德尔不完备性定理的内容。</p>
<p>最后，我们再研究另一个不可计算问题。我们定义语言\(L_D\)，它由全体不接受自己编码的图灵机（即\(\langle M\rangle\notin\mathscr L(M)\))的编码组成。如果语言\(L_D\)可识别，则可以记\(R\)为相应的图灵机。罗素悖论的幽灵再次徘徊。问\(R\)是否接受\(\langle R\rangle\)？根据定义，\(R\)接受\(\langle R\rangle\)当且仅当\(R\)不接受自己的编码，即\(R\)不接受\(\langle R\rangle\)。这一矛盾说明语言\(L_D\)也是不可计算的。</p>
<p>本节包含了大量并不严格或者未加证明的内容，正是因为这部分理论是可计算性理论的核心，严谨的表达需要引入可计算性理论的符号语言。如果有机会，会再对这些结论提供更为严格的表述。</p>
<h2 id="结语"><a class="headerlink" href="#结语"></a>结语</h2>
<p>本文循着Stanford CS103的轨迹，记下了可计算性理论的初步知识。简而言之，本文勾勒出如下的语言层级的大致面貌：</p>
<p>\[\text{RL}\subsetneqq\text{CFL}\subsetneqq\textbf{R}\subsetneqq\textbf{RE}\subsetneqq\text{Languages}\]</p>
<p>对于每个真包含关系，我们都通过正向证明反向举例的方式加以论证<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。这一图景的呈现也基本回答了什么样的问题可以通过程序计算的疑问。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>他的理由是“半龄加七法则”，即要发展关系的双方，一方不得小于另一方年纪的一半再加七岁。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>简单列举一下构造方式。判定补集只需要给原来的确定性有限自动机的可接受状态集取补集。判定并集只需要在新的初始状态添加两个空字符串转移，分别转移到两个子有限自动机，分别判定两个不同的语言。对交集封闭由德摩根律给出。对串接封闭，需要在判定第一个语言的有限自动机的每个可接收状态处添加空字符串转移到判定第二个语言的有限自动机的初始状态。对Kleene闭包封闭，需要添加一个新的可接受的初始状态，它可以空字符串转移到判定每个单独的字符串的有限自动机的初始状态处，同时每个单独的字符串的有限自动机的可接受状态都空字符串转移到这个新的初始状态。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>实际应用中，正则表达式匹配的实现就可以首先翻译为相应的有限自动机，然后再判定是否接受输入字符串。这种方法在匹配速度上的表现也很好。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>首先，任何上下文无关文法都具有Chomsky规范形式，指所有生成式都可以写作\(A=BC\)和\(A=a\)的形式，这里大写字母是非终点表达式，而\(a\)是字母表中的单个字符。每个表达式都可以写出生成树。由于生成式只有有限个，对于足够长的字符串必然会出现单个生成式重复利用的情形，比如会存在\(N\Rightarrow vNy\)这种自我蕴含的结构，这里\(v\)和\(y\)是字符串。我们可以取内层的\(N\)使得\(N\)中不再自我蕴含，而且取所有这样的\(N\)中到叶节点的深度最低的那个。由鸽笼原理，这样的深度不超过生成式的个数\(p\)，于是这样的\(N\)的长度也不大于\(2^p\)。记该字符串为\(x\)。最后这说明原来的字符串可以写作\[S\Rightarrow uNz,\ N\Rightarrow vNy,\ N\Rightarrow x\]的形式。中间那个结构可以反复利用。这就证明了，任意足够长的上下文无关语言的字符串都可以拆分成\(S=uvxyz\)的结构，这里\(x\)非空，且长度不超过\(2^p\)，且\(v\)和\(y\)至少一个非空，且\(uv^kxy^kz\)对于任意\(k>0\)都是该上下文无关语言的字符串。这一命题生动地称为上下文无关语言的泵取引理。回到这个例子，取\(a^nb^nc^n\)中\(n=2^p\)，然后可以分类讨论\(x\)的结构，容易证明无论如何分划，只要利用泵取引理反复泵取，就可以破坏\(a\)、\(b\)和\(c\)的个数相等这一要求。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>关于Church-Turing论题为何相当可信，各大论坛上均有详细的讲解，可以参考。 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>考虑使用<code>willLoop</code>程序的构造。如果<code>willLoop</code>返回真，则返回接受；如果<code>willLoop</code>返回假，则进入死循环；此时还有第三种情况，即<code>willLoop</code>本身就是死循环，这也对应\(\langle{M,s}\rangle\)实际停机的情形。于是，这就招致矛盾。下文中使用验证器的方式，是显式地构造了这样一个<code>willLoop</code>，使得它对会进入死循环的输入返回接受，而对会停机的输入进入死循环。 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>除了\(\text{CFL}\subseteq\bf{R}\)。 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/">有限自动机</a>
            <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
            <a href="/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/">图灵机</a>
            <a href="/tags/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7/">可判定性</a>
            <a href="/tags/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7/">可计算性</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/07/18/note-0005-randomness-and-computation/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">UCB CS271 随机计算（一）</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2021/01/18/note-0003-first-order-logic/">
        <span class="next-text nav-default">一阶逻辑</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:claudy.forrest@email.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">云·弗利斯特</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
