<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="公理化集合论与集合论宇宙"/><meta name="keywords" content="集合论, 序数, 归纳, 递归, 集合论宇宙, 博客" /><link rel="alternate" href="/default" title="博客" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://c-forrest.github.io/2020/12/25/note-0001-elementary-set-theory/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>公理化集合论与集合论宇宙 - 博客</title>
  <meta name="generator" content="Hexo 5.3.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">博客</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">公理化集合论与集合论宇宙
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-12-25
        </span><span class="post-category">
            <a href="/categories/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/">数学笔记</a>
            <a href="/categories/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/%E5%85%83%E6%95%B0%E5%AD%A6/">元数学</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%AD%90"><span class="toc-text">引子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">序数的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E6%95%B0%E3%80%81%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-text">序数、归纳与递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%AE%BA%E5%AE%87%E5%AE%99"><span class="toc-text">集合论宇宙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%EF%BC%9A%E8%87%AA%E7%84%B6%E6%95%B0"><span class="toc-text">题外：自然数</span></a></li></ol>
    </div>
  </div><div class="post-content"><p>参考文献：</p>
<ul>
<li>Enderton. (1977). <em>Elements of Set Theory</em>.</li>
<li>Jech. (2003). <em>Set Theory</em>.</li>
<li>维基百科.</li>
</ul>
<h2 id="引子"><a class="headerlink" href="#引子"></a>引子</h2>
<p>我们相当熟悉集合（set）这一概念。集合大概是具有某类特性的所有对象组成的集体。集合内的元素确定、无序、互异。但是我们难以定义何为集合。我们定义某类事物，通常采用“属加种差”的方法，即称它是如何如何的某物。前文试图把集合描述成某种“集体”，但是我们蛮可以追问，“集体”又是什么。我们实在难以想象集合是何种概念的特化，所以本着实用至上的观点，我们干脆不去定义何为集合。我们把集合看做泛化的极致。每当我们要定义新的对象，我们就称它是怎样怎样的集合。而对于集合是什么，我们避而不谈。实际上，只要不涉及元数学，这种做法不会出任何问题。</p>
<p>尽管我们避免去触碰它，但是问题就在那里。著名的罗素悖论（Russell’s paradox）指出，这种对于集合的不加考量的使用，会导致逻辑上的矛盾。我们通常期望对于任意性质\(P(x)\)，存在集合\(\{x:P(x)\}\)。但是对于性质\(P(x):x\notin x\)，这样的集合在逻辑上不可能存在。这意味着之前默认的对集合的使用可能存在纰漏。这样的思辨引发了所谓的第三次数学危机。虽然数学危机也不影响我们做微积分什么的，我们总归是想要处理好这一问题。</p>
<p>那么问题出在哪呢？从结论上看，很简单。我们不加限定地使用集合，使得集合这一概念的外延太广，而过度的自由必然招致危险。所以，公理化集合论的提出就是为了限制集合概念的使用。最常见的公理化集合论承认ZFC公理体系。这一体系将所有可以使用的集合框定在集合论宇宙（set-theoretic universe，或称von Neumann宇宙）中。集合论宇宙足够大，以至于它可以满足我们所有常规数学讨论的需要，亦即任何常见的数学实体（如\(L^2([0,1])\)等）都可以嵌在这个宇宙中；但是它又并不过大，以致于包含罗素悖论中的这种逻辑谬误。下图是集合论宇宙的简单图示。</p>
<img src="https://i.loli.net/2020/12/21/HTiGKonElCOvyu1.png" alt="von Neumann的集合论宇宙">
<p>粗略地说，这是一个无限向上延伸的塔。所有的集合都位于这个塔的某一层中。最底层是\(V_0\)，它只包含空集\(\varnothing\)。后一层包括前一层乃至前面的所有层，且可以通过前面各层得到。塔的层号自0开始，沿着自然数一直标下去，而后是\(\omega\)，再是\(\omega+1\)，这样逐层向上，无穷无尽。要将这里的故事讲清楚，我们首先得规定合法的集合构造方法，然后定义层数（显然自然数是不够用的），还要克服无穷这一困难。</p>
<p>本文的重点就是围绕ZFC公理体系，勾勒出集合论宇宙的基本面貌。</p>
<a id="more"></a>
<h2 id="基本概念"><a class="headerlink" href="#基本概念"></a>基本概念</h2>
<p>在列举基本概念之前，首先明确，集合论的原始概念只有集合和从属关系（\(\in\)）。作为一阶逻辑体系，ZFC公理及其中的命题完全可以通过集合（作为变量和常量）和从属关系（作为谓词）表述。首先这意味着我们不区分集合和集合中的元素，而把元素也看做是集合。同时，这也意味着我们不会引入类（class）的概念。在其他公理化集合论中，会引入类而把集合视作类的特化，比如可以讨论包括所有集合的类。在那样的语言中，集合论宇宙是一个真类（proper class），即非集合的类。我们遵循Zermelo-Fraenkel体系，不将类纳入公理体系。当然，在叙述中，为了简便，我们往往会使用“元素”和“类”这两个词语，但我们总是把元素理解为集合，并提供更繁琐的不含“类”的表达，而只把“类”看成该繁琐表达的略称。</p>
<p>原则上，我们需要用集合构造地定义所有其他概念。在具体阐述如何构造之前，我们先简单看一下ZFC公理体系的内容。这些公理提供了所有合法的构造集合的手段。ZFC公理中，ZF是Zermelo-Fraenkel集合论公理，C是选择公理（axiom of choice）。选择公理本文不讨论。Zermelo-Fraenkel集合论公理（ZF）如下：</p>
<ul>
<li>外延公理（extensionality axiom）：\(\forall A\forall B(\forall x(x\in A\iff x\in B)\implies A=B)\)</li>
<li>空集公理（empty set axiom）：\(\exists\varnothing\forall x(\neg x\in\varnothing)\)</li>
<li>无序对公理（pairing axiom）：\(\forall u\forall v\exists B\forall x(x\in B\iff x=u\lor x=v)\)</li>
<li>并集公理（union axiom）：\(\forall a\exists B\forall x(x\in B \iff \exists b(b\in a\land x\in b))\)</li>
<li>幂集公理（power set axiom）：\(\forall a\exists B\forall x(x\in B \iff \forall y(y\in x\implies y\in a))\)</li>
<li>子集公理（specification axiom schema）：\(\forall t_1\cdots\forall t_k\forall c\exists B\forall x(x\in B\iff x\in c\land\phi)\)（\(B\)在\(\phi\)中不自由）</li>
<li>无穷公理（infinity axiom）：\(\exists A(\varnothing\in A\land\forall (a\in A\implies a\cup\{a\}\in A))\)</li>
<li>替换公理（replacement axiom schema）：\(\forall A\forall t_1\cdots\forall t_k[\forall x(x\in A\implies\exists!y\phi)\implies\exists B\forall y(y\in B\implies\exists x(x\in A\land\phi))]\)（\(B\)在\(\phi\)中不自由）</li>
<li>良基公理（regularity axiom）：\(\forall A(\exists x(x\in A)\implies\exists y(y\in A\land\neg\exists z(z\in A\land z\in y)))\)</li>
</ul>
<p>ZF公理的表述并不唯一，这里给出的也不是最小的表述。比如，空集公理可以通过无穷公理和子集公理推出。其中，子集公理和替换公理是两个公理模式。任意选取其中的公式\(\phi\)，它们可以产生无数个公理。</p>
<p>外延公理在讲，集合的外延确定集合，即如果两集合所含元素相同，那么两集合相等。空集公理保证了空集\(\varnothing\)的存在性。这也是集合论宇宙构造的起点。无序对公理分别给出了无序对（如\(\{a,b\}\)）、（任意多集合的）并集（\(\bigcup A\)）和幂集（\(\mathscr PA\)）构造的合法性。子集公理则允许我们使用\(\{x\in A:\phi(x)\}\)的方法构造集合。无穷公理保证至少存在一个无穷集。替换公理保证我们可以在比集合更大的尺度（即某些类）上进行映射。良基公理保证了所有集合都在集合论宇宙中，或者更形象地，塔外不存在集合。</p>
<p>朴素集合论的弊端在于集合的定义过于自由。换言之，朴素集合宇宙太大。所以，ZFC公理体系对于集合的扩张处理得十分谨慎。首先，ZFC公理通过子集公理\(\{x\in A:\phi(x)\}\)替换掉了最常见的\(\{x:\phi(x)\}\)构造，从而规避了无限制扩张的集合。有趣的是，子集公理恰恰反映了定义时应遵循的“属加种差”的思想。因而，合法的集合构造往往需要对其所在“属”确实是集合的验证。子集公理规避了罗素悖论。事实上，罗素悖论意味着子集公理成立时，不存在所有集合组成的集合。如果存在这样的集合\(A\)，那么应用子集公理，则\(\{x\in A:x\notin x\}\)定义合法，罗素悖论中的矛盾立即否认了集合\(A\)的存在。然后，ZFC留下了三种集合扩张手段：构造无序对、并集和幂集。至此的六个公理足以处理所有有穷集（虽然我们还没有定义有穷集）问题。余下的公理中，无穷公理、替换公理（和选择公理）都是为了处理无穷带来的困难而引入的。良基公理最为特殊，它单纯是一种宣言，否认了塔外的（畸形）集合的存在。</p>
<p>在理解无穷和无穷带来的困难之前，我们先快速地列举ZFC体系中能够合法构造的概念。常见的集合概念中，从属\(\in\)、并集\(\cup\)都已经给出<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，而包含\(\subseteq\)、交集\(\cap\)、差集\(\setminus\)也不难定义。容易验证，常见的集合运算律均成立。第一个新的概念是有序对（ordered pair），即\((a,b)\)。一个好的定义是\(\{\{a\},\{a,b\}\}\)<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。进而可以定义两集合的笛卡尔积（Cartesian product），即\(A\times B=\{(a,b):a\in A\land b\in B\}\)<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。两集合笛卡尔积的任意子集都称作二元关系（binary relation），常把\((x,y)\in R\)写作\(xRy\)。下面讨论几种重要的二元关系。一是映射（function），特殊地，有单射、满射、双射。对于映射可以讨论其定义域、值域、逆、复合、限制、像等。二是等价关系（equivalence），即定义在集合自笛卡尔积上的满足自反、对称、传递的二元关系。一般地，集合可以按照其上的等价关系划分为等价类，进而讨论商集和其上诱导的商映射。三是偏序关系（partial order），（弱序）即定义在集合自笛卡尔积上的满足自反、反对称、传递的二元关系。完备的偏序称为线序（linear order）。每当谈到一个偏序，我们总是依语境使用其弱序或严格序而不加严格区分。这里所涉及的概念，由于都应当是熟悉的，所以不多加讨论。这里只是强调它们怎样从集合论中构造出来。最后，两集合上的全体二元关系，或全体映射，或全体偏序，都是\(\mathscr P(A\times B)\)的子集。常记\(A\rightarrow B\)的全体映射集为\(B^A\)。</p>
<h2 id="序数的结构"><a class="headerlink" href="#序数的结构"></a>序数的结构</h2>
<p>序数是自然数的自然延伸。我们需要序数，因为自然数太少了。能使用自然数标号的集合论宇宙很小，无法满足我们的需求。当自然数用尽时，我们想要把“无穷”也作为新的标号，然后使用“无穷加一”，“无穷加二”等等，甚至到“无穷加无穷”，然后再是“无穷的两倍加一”，一直到“无穷的无穷倍”，再来“无穷的无穷倍加一”。或者我们把“无穷的无穷倍”记做“无穷的二次方”，还可以想象“无穷的无穷次方”，再“加一”，永不穷尽<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。</p>
<p><img src="https://i.loli.net/2020/12/22/jWZIGc82xfKSbXh.png" alt="序数示意图"></p>
<p>（图源：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transfinite_induction">Wikipedia - Transfinite induction</a>）</p>
<p>难点在于如何将这一想法严格化。现在常见的序数的构造也是von Neumann提出的。我不清楚von Neumann如何得到这一构造，但是可以为其提供一点动机。序数的基础结构是序结构。标号总有前后，抽象出来就是序结构。序数也正是得名于此点。而且不难想见，序数应当是严格线序，即任意两个标号都能够分出前后，且不存在两个并列的序数。更重要的特点是，所有序数都是可以“数”得到的<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。更没有歧义的说法是，一些序数中总有一个最小的。这相当于某种可归纳性。比如说，当我们需要为所有序数建立某个性质时，我们可以找到首个不满足该性质的序数，然后如果我们可以证明所有比它小的序数成立时，对该序数也应当成立，立马就得到矛盾。这可以看做是第二数学归纳法在序数上的推广，序数上又称超限归纳法。满足任意非空子集都有最小值这一条件的赋线序的集合称为良序集（well-ordered set）。我们将要看到，良序集反映了序数的本质。</p>
<p>我们先看看我们究竟能够良序集这一假定中得到什么。首先，任意两个良序集都可以比较。考虑两个人每人拿一个良序集，在桌子上轮流将元素从小到大依次摆出，总有一个人会先出完<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。这就意味着全体良序集上面天然具备一种“序结构”<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>，其对应弱序是完备且传递的。这一序结构很自然地给出序数的定义。但唯一的缺陷就是这个序结构不是线序，可能存在两个不同的良序集里元素一样多。这意味着我们需要考虑全体良序集在该序结构下的等价类，而序数取做该等价类的代表元。代表元的选取，则有相当的任意性。首先注意到，任意良序集\((A,&lt;)\)都同构于其前段（initial segment）上的良序，这里前段即\(\text{seg}(t)=\{x\in A:x&lt;t\}\)，所以考虑用\(\text{seg}(t)\)替换\(t\)，从而忽略到原来良序集中的序。比如说，将良序集\(q&lt;w&lt;e\)替换成\(\varnothing\subset\{q\}\subset\{q,w\}\)，这两个序结构同构，但我们不再需要知晓\(&lt;\)。这是一种抽象<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>。序数则构造成在这一抽象下保持不变的形式，即如果有序数\(0&lt;1&lt;2&lt;3\)，那么\[0=\varnothing,\ 1=\{0\}=\{\varnothing\},\ 2=\{0,1\}=\{\varnothing,\{\varnothing\}\},\ 3=\{0,1,2\}=\{\varnothing,\{\varnothing\},\{\varnothing,\{\varnothing\}\}\},\ \cdots\] 这正是von Neumann构造，即每一序数都是比它小的所有序数的集合。其上的序可以是\(\in\)，也可以是\(\subset\)，我们取前者，因其简单性。注意，本段中有诸多可能不合法的构造，比如说我们尚未论证任意良序集在上述抽象后得到的结果还是集合。这些都留作后文讨论。</p>
<p>总结一下前文所述的序数定义。序数都是比它小的所有序数的集合，但我们并不能这样定义序数。因为“小”是相对集合内元素而言的，但是集合自身并不能纳入比较。因此，我们定义集合\(\alpha\)为序数，若\(\alpha\cup\{\alpha\}\)是关于\(\in\)严格良序的。或者<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>，按通行的表述，集合\(\alpha\)是序数（ordinal number），若\(\alpha\)关于\(\in\)严格良序，且\(\alpha\)是传递集（transitive set），即若\(x\in a\in\alpha\)，则\(x\in\alpha\)<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。传递集这一特性正是为将序数本身纳入比较提供便利。立马可证<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，\(\varnothing\)是序数，且全体序数关于\(\in\)构成严格良序的传递类。后者在集合的语言中可表述为，(i) 任意两个序数关于\(\in\)都可比较，满足三歧性和传递性，(ii) 任意序数的元素都是序数，且(iii) 任意序数的非空集合都有最小元。最后，这也意味着全体序数过多，并不能成为集合。若不然，全体序数集也是序数，但自三歧性又知序数不能属于自身，矛盾。全体序数类记作\(Ord\)。注意，我们可以讨论不在某集合中的最小的序数<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，尽管集合的补不再是集合。</p>
<h2 id="序数、归纳与递归"><a class="headerlink" href="#序数、归纳与递归"></a>序数、归纳与递归</h2>
<p>到目前为止，我们确知的序数只有空集\(\varnothing\)。由前文的讨论也不难证明，若\(\alpha\)是序数，则其后继数\(\alpha^+=\alpha\cup\{\alpha\}\)也是序数。于是，目前的序数包括\(\varnothing,\varnothing^+,\varnothing^{++},\varnothing^{+++},\cdots\)。紧接着的序数就应当是它们的全体。但这样的构造并不合法。通过有限步无序对、并集和幂集运算无法构造这样的集合。故而需要无穷公理，强行假定这样集合的存在。称集合\(A\)为归纳集（inductive set），若\(\varnothing\in A\)且若\(a\in A\)，则\(a^+\in A\)。无穷公理称至少存在一个归纳集。我们定义\(\omega\)为最小的归纳集，即\(x\in\omega\)当且仅当它属于所有归纳集（相当于类语言中，全体归纳集类的交集）。随后是\(\omega^+,\omega^{++},\omega^{+++},\cdots\)。问题再次出现：将这些序数组成新的集合，合法吗？很遗憾，无穷公理无法保证存在两个归纳集。如果不想每次出现新的归纳集就重新引入新的公理，就需要找到简单的通用的构造方法。</p>
<p>这一问题的解决方案是引入替换公理。事实上，“\(\omega\)系列”看起来可以一一对应“\(\varnothing\)系列”，两者长度相仿。但是两者之间暂时并不存在映射，因为尚未确知“\(\omega\)系列”是集合。可是既然“\(\varnothing\)系列”已经成为集合，这说明这一系列并没有大到不构成集合。如果对每个“\(\varnothing\)系列”中的元素都能够唯一对应到“\(\omega\)系列”中的某个元素，且“\(\omega\)系列”中不再含有其他元素，那么说明“\(\omega\)系列”的体量也没有大到不成为集合。替换公理在类的语言下就是，集合在类上的映射下的像也是集合。用集合语言，类上的映射就是命题\(\gamma(x,y)\)，且满足\(\forall x(x\in A\implies\exists!y\gamma(x,y))\)，而相应的像集就是\(\exists B(\forall y\in B\exists x\gamma(x,y))\)。替换公理保证“\(\omega\)系列”也是集合，那么将该集合同“\(\varnothing\)系列”并在一起就是新的序数了。</p>
<p>依赖于替换公理，可以证明所有良序集都同构于某个序数。想法很直接，从头开始逐个对应。比如说，给定良序集\(A\)，逐个对应的过程进行到\(t\in A\)，正考虑要将\(t\)对应为哪个序数。由于序数由比它小的全体序数所确定，只需要把已经对应好的\(A\)的到\(t\)为止的前段\(\text{seg}(t)\)相对应的序数拢在一起。由替换公理，这些序数构成集合。该集合就是\(t\)所对应的序数。由此，我们严格证明了，序数就是良序集在序同构意义下等价类上的代表元。常常讲，序数是良序集的序型（order type）。</p>
<p>包括构造良序集的序型在内，上文已经多次反映了处理无穷常见的方法，即归纳（induction）和递归（recursion）。它们都可以应用在某种序结构上，这里以良序集为例。它们的特点是，每步操作都依赖于（序结构意义下）之前的操作的结果；当然往往需要一个操作的起始点。归纳常用于证明命题。比如说要证明关于良序集\(A\)中元素\(a\)的命题\(\phi(a)\)。如果已知命题对所有之前的元素成立时就对当前元素成立，即\(\forall b(b&lt;a\land\phi(b))\implies \phi(a)\)，且命题对该良序集最小元成立，那么该命题就对所有\(A\)中的元素都成立。若不然，考量最小的使该命题不成立的\(a\)，则根据归纳时的命题和初始条件就已经构成矛盾。</p>
<p>递归则用于构造映射。比如说已知初值和递归式\(F(t)=G(F\upharpoonright\text{seg}(t))\)，即\(F(t)\)依赖于它在\(\text{seg}(t)\)上的限制<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>，或者说是它在\(t\)之前所有值上的取值。此时，\(F(t)\)的构造就需要通过递归来完成。这里得到的\(F\)甚至可以定义在类上，比如全体序数上，当然我们是通过定义它在所有序数上的限制来完成的。这一思想类似于通过层层摞着的纸牌伸出桌面<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>。事实上，即使\(F\)的定义域是集合，我们也是用同样的思想完成的。考察所有\(F\upharpoonright\text{seg}(t)\)有定义的元素\(t\)组成的集合\(B\)，其中每个\(F\upharpoonright\text{seg}(t)\)都满足初始条件和到\(t\)为止的递归式。可以证明对每个\(t\in B\)，限制\(F\upharpoonright\text{seg}(t)\)都是唯一确定的。由替换公理，\(\{F\upharpoonright\text{seg}(t):t\in B\}\)的确是集合，考察它（作为二元关系）的并。可以归纳证明该并是映射，满足递归条件且定义域\(B\)为全体\(t\)。我们还可以确定递归构造结果的唯一性。</p>
<p>在良序集上的归纳和递归通常称为超穷归纳（transfinite induction）和超穷递归（transfinite recursion）。实际应用中，它们往往呈现更强的形式。这是基于如下考虑。序数可以根据是否具有前置数分为三类<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup> <sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>：\(\varnothing\)，后继序数\(\alpha=\beta^+\)和极限序数\(\alpha=\bigcup\alpha\)。归纳时，常常后继序数命题成立，只要其前置数命题成立；而递归时，往往极限序数处只是对之前所有序数取并。这都大大简化了归纳和递归的过程。</p>
<p>序数上可以建立算术运算。有两种等价的方式，一是通过序型，二是通过递归。序型的方式更为直观和本质，因为这一运算实际上是可以对良序集进行的。任给两良序集\(A\)和\(B\)，\(A+B\)定义成将\(B\)接在\(A\)之后所得的序，\(A\cdot B\)定义成笛卡尔积\(B\times A\)上的字典序<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>。当检查完这些确为良序集，并确定所得序的序型只与两良序集的序型有关时，这就变成序数上的运算。另一种方式则是递归定义。定义\(\alpha+\beta\)、\(\alpha\cdot\beta\)和\(\alpha^\beta\)时总是固定\(\alpha\)，对\(\beta\)递归。比如，\(\alpha+\beta\)定义成递归映射：首先，\(\alpha+0=\alpha\)；对后继序数\(\beta^+\)，有\(\alpha+\beta^+=(\alpha+\beta)^+\)；对极限序数\(\beta\)，有\(\alpha+\beta=\bigcup_{\xi\in\beta}(\alpha+\xi)\)。由超穷递归，如此定义的映射唯一。对\(\alpha\cdot\beta\)和\(\alpha^\beta\)的定义也类似。序数的加法和乘法不满足交换律，但仍满足结合律。加法对于所有\(\alpha\)都关于\(\beta\)严格单增，乘法需要\(\alpha\ni0\)，幂需要\(\alpha\ni1\)。严格单增的结果是满足消去律，所以序数上可以定义减法、除法和对数运算<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>。</p>
<h2 id="集合论宇宙"><a class="headerlink" href="#集合论宇宙"></a>集合论宇宙</h2>
<p>我们业已提供了所有必要的集合构造方式。通过这些能够得到的集合的全体中不免含有一些畸形的怪胎。比如说，可能存在Quinn原子（Quinn atom）形式的集合\(x=\{x\}\)。这些异常的集合混杂于集合论宇宙之中，对我们使用集合通常并无裨益，反而为某些通常认为成立的命题提供了若干反例。定义集合论宇宙就是为集合的全体划定合理的范围，试图剔除这些异常的集合。应当提到，把这些所谓畸形的集合纳入集合论宇宙中并不会造成逻辑上的矛盾，开除它们的集合籍只是因为我们认为它们的存在并无必要。</p>
<p>应当如何划定集合论宇宙的范围呢？显然，我们不能取全体序数作为集合论宇宙，这样甚至集合\(\{1,2\}\)都不在范围内。我们划定的集合论宇宙应当对通常的集合构造方式封闭。事实上，von Neumann的描述基于非常简单的想法。因为集合大概就是把元素拢在一起，所以集合论宇宙应当对“拢在一起”这一操作封闭，即如果某个集合的元素都在集合论宇宙里，那么这个集合也在集合论宇宙中。既然它已经是集合，那么它的元素不会过多而无法成为集合；而它的元素又都已经具有了集合籍，我们也没道理开除其本身的集合籍。</p>
<p>形式上，集合论宇宙自\(V_0=\varnothing\)开始<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>，进行超穷递归。对后继序数\(\alpha=\beta^+\)，取\(V_\alpha=\mathscr PV_\beta\)；对极限序数\(\alpha\)，取\(V_\alpha=\bigcup_{\beta\in\alpha}V_\beta\)。每步递归时，都取幂集，这就提供了之前得到的所有集合的所有可能的“拢在一起”的方式。可以通过超穷归纳证明，\(V_\alpha\)为传递集，且\(V_\alpha\)在\(\in\)和\(\subset\)序下都是严格单增的。该定义也有更紧凑的形式，可以等价地写做\(V_\alpha=\bigcup\{\mathscr PV_\beta:\beta\in\alpha\}\)。集合论宇宙就是这一\(V_\alpha\)的极限，显然它是真类。但是我们不妨记它为\(V=\bigcup_{\alpha\in Ord}V_\alpha\)，这里\(Ord\)为全体序数类。</p>
<p>集合论宇宙中的每个集合都有其唯一的层号。定义集合论宇宙中集合的层号（rank）为\(\text{rank}\,A=\min\{\alpha\in Ord:A\subseteq V_\alpha\}\)<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>。如果集合在塔中，则其元素均在塔中，且元素的层号严格小于集合的层号；反过来，如果某集合所有元素都在塔中，则集合也在塔中，且层号满足\(\text{rank}\,A=\bigcup_{a\in A}(\text{rank}\,a)^+\)<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>。这就说明集合论宇宙确实对“拢在一起”这一操作封闭。由此，可以归纳证明对所有序数\(\alpha\)都成立\(\text{rank}\,\alpha=\alpha\)。</p>
<p>全体集合都在集合论宇宙中其实并没有证明。比如说，Quinn原子不可能在这样的宇宙中<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>，但允许Quinn原子的存在也不会造成矛盾。所以，全体集合都在塔中这件事，可以看作集合论的又一公理，而非又一命题。但这样的公理显得太过复杂，我们期望更简洁的表述。在其他ZF公理条件下，这实际等价于良基公理。良基公理声称，所有集合都是\(\in\)序上的良基集，即所有集合中都有\(\in\)序上的极小元。对于塔中的集合，良基公理显然，只要取集合中层数最小的元素即可。反之，对于不再塔内的集合，可以取其不在塔内部分的\(\in\)序上的极小元，则由其极小性立知其元素都在塔中<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>，而塔对“拢在一起”操作封闭，即得矛盾。良基公理事实上保证了集合论宇宙中不存在关于\(\in\)的严格降链，这说明全体集合的良基性。归纳和传递的思想可以推广到良基集上，所以理论上要对全体集合证明某命题，可以通过依\(\in\)归纳得到：如果已知某关于集合的命题成立，若它对集合的全体成员都成立，就可以确信该命题对所有集合都成立。</p>
<h2 id="结语"><a class="headerlink" href="#结语"></a>结语</h2>
<p>至此，我们已经说明了ZF公理如何保证集合论宇宙的存在。<a target="_blank" rel="noopener" href="https://plato.stanford.edu/entries/set-theory/#UniVAllSet">斯坦福哲学大百科</a>中对此做了精妙的总结，我们转述如下：</p>
<blockquote>
<p>集合论宇宙后验地支持了ZF公理（除天然成立的外延公理）的正当性。空集公理提供了构造起点\(V_0=\varnothing\)。幂集公理保证了后继序数处\(V_{\alpha^+}=\mathscr PV_\alpha\)的合法性。替换公理和并集公理保证了极限序数处\(V_\alpha=\bigcup_{\beta\in\alpha}V_\beta\)的合法性。无穷公理保证了\(\omega\)乃至更多的无穷序数的存在。在其他公理的基础上，良基公理则说明所有集合必然在如此构造的集合论宇宙中。</p>
</blockquote>
<p>虽然我们已经描绘了一幅大的集合论宇宙的图景，但这图景相当模糊，尚有很多细节需要厘清。可能以后会进一步讨论它们。集合论宇宙有多大？我们没有明确的答案。因为实际上我们并不知道集合的幂集有多大，也不知道全体序数列有多远。正如前文所看到的，如果没有无穷公理，序数列中甚至不会出现无穷，而如果没有替换公理，序数列中也不会出现\(\omega\cdot2\)。我们可以定义更多形式的特殊的“大”序数，它们的存在性实际上都独立于现有的ZFC公理体系。这些都会影响集合论宇宙的实际规模。值得庆幸的是，常见的数学理论都可以在\(V_{\omega+\omega}\)中建立，所以更远的序数存在与否对这些理论并没有太大影响。</p>
<p>最后，谈到公理化集合论不免要提及这个数学理论的“宠儿”——选择公理。虽然ZF公理都有着普遍的应用，但唯独选择公理，每每使用都会显式地说明。很遗憾，篇幅所限，我们甚至没有给选择公理一个严格表述，虽然我们多次有过这样的机会。选择公理在通行的理论数学框架中有着基础的重要性，虽然它的成立与否并不影响集合论宇宙的构造的可行性。正因如此，聚焦于集合论宇宙的我们没有匆匆谈及它，而留待日后单独论述。</p>
<h2 id="题外：自然数"><a class="headerlink" href="#题外：自然数"></a>题外：自然数</h2>
<p>Enderton的书中，自然数是单独开辟了章节讨论的。但是，在von Neumann构造中，自然数只是特殊的序数。从自然数的构造上并不能阐述von Neumann序数构造方式的合理性，因而我把它从主干中摘了出去。但是自然数本身又是数理逻辑的重要模型，不能不提，故特开一题外简单解释一下自然数的基本理论。</p>
<p>在von Neumann构造中，自然数（natural number）定义为所有小于\(\omega\)的序数，所以\(\omega\)也称为自然数集。自然数集是按照\(\in\)严格良序的，这里的\(\in\)恰巧就是日常生活中自然数上最常见的序关系。作为良序集，自然数上成立归纳原理和递归原理。这种归纳称为第二数学归纳法。常用的形式是它的弱化版本<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>，数学归纳法。序数的算术运算也都可以限制在自然数集上。但对于自然数，加法和乘法都成立交换律。这些就是自然数集的基本结构，事实上，它与我们通常对自然数的认识并无不同。</p>
<p>除了构造定义外，自然数集也有公理化定义。这就是著名的Peano公理（Peano postulates）。我们称\((\mathbb N,0,S)\)是Peano系统，如果(i) \(0\in\mathbb N\)；(ii) \(S:\mathbb N\rightarrow\mathbb N\)是单射，且值域不含\(0\)；(iii) 任何含\(0\)且对\(S\)封闭的\(\mathbb N\)的子集必然等于\(\mathbb N\)本身（归纳公理）。显然，这里的\(S\)就是后继数运算符。事实上，前文定义的\((\omega,\varnothing,\sigma:n\mapsto n^+)\)是一个Peano系统，且任何Peano系统都将同构于\((\omega,\varnothing,\sigma)\)。从Peano公理来看，自然数集的本质就是最小的归纳结构。应当指出，自然数在集合论中的实现并不唯一，比如Zermelo构造中就取\(n^+=\{n\}\)，它也符合Peano公理，都是自然数集的合理模型。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>严格来说，并集公理只给出了若干个集合的并的构造合法性，而\(A\cup{}B\)是通过\(\bigcup\{A,B\}\)定义的，它的合法性同时依赖于无序对公理和并集公理。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>可证\((a,b)=(c,d)\)当且仅当\(a=c\)且\(b=d\)。利用无序对公理和外延公理分类讨论即可。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>该定义合法，因\(A\times{}B\subseteq\mathscr{P}\mathscr{P}(A\cup{B})\)。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>有没有小学生吵架比大小那味道了…… <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>不是常见的“可数”的概念。这里的“数”需要能“数”到无穷大，而无穷一般是不可数的。 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>严格来说，考虑两良序集\(A\)和\(B\)，并考虑\(H=\{(x,y):A(x)\simeq{}B(y)\}\)，这里\(A(x)=\{a\in{}A:a&lt;_Ax\}\)，\(B(y)\)类似，而\(\simeq\)是序同构（保序双射）。那么给定\(x\)，有唯一的\(y\)成立\(xHy\)。假设不然，有\(y_1&lt;_By_2\)使得\(B(y_1)\simeq{}A(x)\simeq{}B(y_2)\)。作为良序集的子集，\(B(y_1)\)和\(B(y_2)\)都是良序集。但是，良序集没有非平凡自同构。事实上，任何保序自变换\(f\)都满足\(x\le{}f(x)\)；否则取成立\(f(x)&lt;x\)最小的\(x\)，由其最小性，\(f(x)\le{}f(f(x))\)，这立马与该自变换的保序性相悖。类似地，给定\(y\)，有唯一的\(x\)成立\(xHy\)。所以，\(H\)应当是在\(A\)和\(B\)子集上的双射。实际上，必然有\(\text{dom}(H)=A\)或\(\text{ran}(H)=B\)，这就得到了自\(A\)到\(B\)前段（即某个\(B(y)\)，下同）的序同构，或自\(A\)前段到\(B\)的序同构，或自\(A\)到\(B\)的序同构。分别记这三种情形为\(A&lt;B\)，\(B&lt;A\)和\(A\sim{}B\)。因良序集没有非平凡自同构，有\(\neg(A&lt;A)\)，三种情形互斥。最后，容易验证它也满足传递性。 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>这里的引号是因为这是类上的序结构。 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程。 <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>容易检查两定义等价性。 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>一般地，称集合\(A\)是传递集，如果以下四个等价条件（之一）成立：(i)\(\bigcup{A}\subseteq{}A\)；(ii)\(A\subseteq\mathscr{P}A\)；(iii)\(\forall{a}(a\in{}A\implies{}a\subseteq{}A)\)；(iv)\(\forall{x}\forall{}a(x\in{a}\in{A}\implies{}x\in{}A)\)。 <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>首先，验证定义可知，\(\varnothing\)是序数，且任给\(\beta\in\alpha\)，若\(\alpha\)是序数，则\(\beta\)也是序数。考察\(\alpha\)的前段\(\text{seg}(\beta)=\{x\in\alpha:x\in\beta\}\)，显然\(\text{seg}(\beta)\subseteq\beta\)。但\(\beta\subseteq\text{seg}(\beta)\)也成立，因为\(\alpha\)是传递集。所以，这个前段就是\(\beta\)。另外，序数间的序同构就是相等。不妨取\(\alpha\simeq\beta\)但两者不等，记自同构为\(f\)，取成立\(x\neq{}f(x)\)的最小的\(x\)，但比\(x\)小的所有元素都比\(f(x)\)小，反之亦然，故两者相等，矛盾则证\(\alpha=\beta\)。再有前文脚注就知道序数的三歧性。传递性显然。良序性也不难。 <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>因为全体序数不是集合，一定存在不在该集合中的序数，设为\(\gamma\notin{T}\)。然后只要考察比\(\gamma\)小的序数中不属于该集合的序数\(\beta\)。假设有\(\alpha\in\beta\)且\(\alpha\notin{T}\)，则由传递性，\(\beta\in\gamma\)，则\(\alpha\in\gamma\)，这与\(\beta\)的最小性相悖。 <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>严格来说应当写作命题的形式，即\(\gamma(F\upharpoonright\text{seg}(t),F(t))\)，因为一般地，\(G\)不是（集合意义下的）映射。 <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>理论上可以伸出到无限远，见<a target="_blank" rel="noopener" href="https://www.guokr.com/article/4437/">这里</a>。 <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>正整数可以根据是否有除了1和自身以外的质因数分为1、质数和合数三类。 <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>固定序数\(\alpha\neq\varnothing\)。因为\(\alpha\)是传递集，\(\bigcup\alpha\subseteq\alpha\)。检查定义可知，\(\bigcup\alpha\)也是序数，序数上\(\subset\)形成的严格序和\(\in\)一致。故\(\bigcup\alpha\in\alpha\)或\(\bigcup\alpha=\alpha\)。若存在\(\beta\)使\(\alpha=\beta^+\)，则\(\bigcup\alpha=\beta\cup\bigcup\beta=\beta\in\alpha\)，因为\(\beta\)也是传递集。反之，若\(\bigcup\alpha\in\alpha\)，则记\(\beta=\bigcup\alpha\)，\(\beta\)也是序数。若\(\alpha\in\beta^+\)，则\(\alpha\in\beta\)或\(\alpha=\beta\)，矛盾，所以\(\beta^+\in\alpha\)或\(\beta\in\alpha\)。而若\(\beta^+\in\alpha\)，同理有\(\beta^{++}\in\alpha\)或\(\beta^{++}=\alpha\)，亦即\(\beta^{++}\subseteq\alpha\)，则\(\beta^+=\bigcup\beta^{++}\subseteq\bigcup\alpha=\beta\)，矛盾。于是必有\(\beta^+=\alpha\)。所以非零序数是且仅是后继序数或极限序数之一。 <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>\(B^A\)上的序不再是简单的字典序，尤其是当\(A\)是极限序数时。 <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>序数有所谓Cantor规范形式。就是将某非零序数对\(\omega\)取对数，将所得余数再对\(\omega\)取对数，循环往复。由于序数是良序集，该单调降列必然在有限步后终止。结果，每个非零序数\(\alpha\)都可以唯一写作\(\alpha=\omega^{\gamma_1}{\cdot}n_1+\omega^{\gamma_2}{\cdot}n_2+\cdots+\omega^{\gamma_k}{\cdot}n_k\)的形式。这里，\(k,n_1,n_2,\cdots,n_k\)是自然数，\(\alpha>\gamma_1>\gamma_2>\cdots>\gamma_k\)是严格降的序数列。 <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>“无，名天地之始。” <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>如果定义为最小的\(\alpha\)使得\(A\in{}V_\alpha\)，则第\(0\)层和第\(\beta\)层（\(\beta\)为极限序数）中将不再含有新的元素。 <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>需要替换公理。对集合\(A\)中每个元素\(a\)都取其层号\(\text{rank}\,a\)，则由替换公理，这些层号也构成集合，因此\(\bigcup_{a{\in}A}(\text{rank}\,a)^+\)是合法序数。 <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>由\(x{\in}x\)可知，\(\text{rank}\,x\in\text{rank}\,x\)，矛盾。 <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>事实上，该集合的成员的成员未必是该集合的成员，所以这一极小性并不能保证极小元的成员仍在塔中。技术上，需要保证该塔外的集合是传递集。对于一般的集合，需要取其传递集闭包。 <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>弱化版本，指归纳假设减弱。所以数学归纳原理是比第二数学归纳原理更强的命题。英文书籍中，通常称第二数学归纳法为“强”数学归纳，也是这个原因。 <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/%E9%9B%86%E5%90%88%E8%AE%BA/">集合论</a>
            <a href="/tags/%E5%BA%8F%E6%95%B0/">序数</a>
            <a href="/tags/%E5%BD%92%E7%BA%B3/">归纳</a>
            <a href="/tags/%E9%80%92%E5%BD%92/">递归</a>
            <a href="/tags/%E9%9B%86%E5%90%88%E8%AE%BA%E5%AE%87%E5%AE%99/">集合论宇宙</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/01/04/note-0002-elementary-set-theory-2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">基数与选择公理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2020/12/19/notes-preface/">
        <span class="next-text nav-default">写在前面</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:claudy.forrest@email.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">云·弗利斯特</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
